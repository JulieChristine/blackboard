<p>Getting started with Ember.js is easy. Ember projects are created with the command line build tool Ember CLI (Command Line Interface).</p>

<strong>Ember CLI should be installed and ready for use on your computers. The following instructions are meant for installation and configuration on your own personal machine.</strong>

To install Ember CLI on your personal device, you will first need to install:

<ul>
  <li>Node.js</li>
  <li>Bower</li>
  <li>Watchman</li>
</ul>

<h3>Windows / Linux</h3>
<hr>

<p>On Windows or Linux systems, download and install Node.js from the Node Website, as detailed in this video.<p>

<p>After installing, confirm you have access to node and npm (node package manager, installed automatically with Node) commands, and the correct versions by checking the versions through the command line, as seen below. Node should should be 4.0.x or higher, npm should be 3.6.x or higher:</p>

$ node -v
v6.2.0
$ npm -v
3.10.5

<p>Then, in your home directory, install bower using npm:</p>

$ npm install -g bower

<p>Finally, install ember-cli using npm:</p>

$ npm install -g ember-cli

<p>You can test that Ember is correctly installed by making an empty test project:</p>

$ ember new project-name

<p>The new command will automatically generate a project with the required Ember files and directories. Navigate to the top-level of this project in the command line:</p>

$ cd project-name

<p>And attempt to launch the Ember server:</p>

$ ember server

<p>Navigate to localhost:4200 in your browser. You should be greeted by a welcome page.</p>

<h4>Windows Build Times</h4>

<p>It's a known issue that build times for Ember projects can take much longer on Windows than Mac or Linux. Two services build into Windows: Windows Defender (meant for protecting against viruses) and Windows Search Index (responsible for indexing files for quick location) monitor all new files created on your machine. When an Ember project is built, many temporary files (most of which we never even see!) are created. As this occurs, these two Windows tools temporarily lock and examine each file, which takes additional time.</p>

<p>If you experience this, know that this is normal, and likely not due to your specific machine. However, there are several things you can do to improve build speeds.</p>

<h5>ember-cli-windows</h5>

<p>The additional ember-cli-windows package improves build times in Windows environments by by disabling the Windows Search Index and Windows Defender tools only in the tmp folder in Ember applications. This is considered safe, if only because the tmp files will only ever hold copies and compilations of your existing code.</p>

<p>Simply run the following commands from the root of each new Ember project:</p>

$ npm install ember-cli-windows -g
$ ember-cli-windows

<p>The first command installs the package, and the second prompts it to configure Windows Defender and Windows Search for the current project's directory.</p>

<h4>Additional Resources</h4>
<hr>

<p>Further details about the installation process can be reviewed in the Ember CLI Getting Started documentation.</p>

<h3>OSX</h3>
<hr>
<p>On OS X systems, install Node.js through Homebrew with the following command in your home directory, or visit the Node website and download the appropriate installer for your operating system:</p>

$ brew install node

<p>Confirm that node and npm (node package manager, installed automatically with Node) are in place by checking the versions (Node should should be 4.0.x or higher, npm should be 3.6.x or higher):</p>

$ node -v
v6.2.0
$ npm -v
3.10.5

<p>(If you have an older version of Node already installed, upgrade through Homebrew by running $ brew upgrade node.)<p>

Remaining in your home directory, install bower using npm:

$ npm install -g bower
On OSX, also install watchman using Homebrew (Watchman does not yet offer a stable Windows version, but Ember-CLI will function without it. For more details, see the Watchman section of the Ember CLI "Getting Started" Guides ).

$ brew install watchman
Finally, install ember-cli using npm:

$ npm install -g ember-cli
You can test that Ember is correctly installed by making an empty test project:

$ ember new project-name
The new command will automatically generate a project with the required Ember files and directories. Navigate to the top-level of this project in the command line:

$ cd project-name
And attempt to launch the Ember server:

$ ember server
Navigate to localhost:4200 in your browser. You should be greeted by text that says "Welcome to Ember.js".

Ember Core Concepts
Before we start writing any Ember code, let's consider some terminology associated with Ember and then walk through a broad overview of how an Ember application works.

Like Angular, Ember is one of many "client-side MVCs". MVC stands for "model-view-controller". In Ember 2.0, the acronym, "MTC", or "model-template-component" would perhaps be more accurate, but despite any differences in naming the general concept is the same. Models persist data, templates present the data and user interface, and components handle how the application behaves between user interaction, templates and models.

Let's further explore how different portions of an Ember application interact. We'll begin by considering how the router and route handlers process a URL request.

URL, Router and Route Handler
Imagine we are writing an application for a vacation rental company called Super Rentals. This application allows users list their properties for visitors and vacationers to rent, similar to sites like AirBnB.

Like many websites and applications, the web URL for an Ember application should change depending on what page or area the user is visiting. This means we should be able to answer questions about the application's current state like "What rental is the user currently viewing? and "Are they editing it?" simply by looking at the application's URL.

The URL can be set in a few different ways:

The user loads the app for the first time.
The user changes the URL manually by clicking the back button or by editing the address bar.
The user clicks a link within the app.
Some other event in the app causes the URL to change.
No matter how the URL is determined, the Ember router always maps the URL to a route handler first. That is, Ember seeks an entry on the Router that matches the current URL, and loads the route handler that corresponds to that route. Essentially, the format and information in the URL determine which area of the site to load.

Once loaded, the route handler has two primary responsibilities:

It renders a template.
It loads model information that is made available to that template.
Ember core concepts

Templates
Similar to Angular, Ember.js uses templates to organize the layout of HTML in an application. Most templates in an Ember codebase are instantly familiar, and look like any fragment of HTML. For example:

<div>Hi, this is a valid Ember template!</div>
Ember templates use the syntax of Handlebars templates. Anything that is valid Handlebars syntax is valid Ember syntax. Templates can also display properties provided to them from their context, which is either a component or a route. For example:

<div>Hi {{name}}, this is a valid Ember template!</div>
Here, {{name}} is a property provided by the template's context. Besides properties, double curly braces {{}} also known as Handlebars, for their handlebar-like appearance, may also contain helpers and components, which we'll explore a little later. Essentially, they're a manner of inserting and displaying dynamic data in a template.

Models
Models represent persistent state.

For example, a property rentals application needs to save the details of each rental a user publishes. A rental would therefore require a model defining its details; most likely called the rental model. A model typically persists information to a web server, although models can be configured to save to anywhere else, such as the browser's Local Storage.

Components
While templates control how a user interface looks, components control how the user interface behaves.

Unlike the other portions of an Ember application we have discussed so far, components consist of two files: A template written in Handlebars, and a source file written in JavaScript. The files have the same name, but the template ends in the Handlebars .hbs extension, and the source file ends in the JavaScript .js extension.

The template defines what the component should look like and the source file controls what functionality that component has. Components are called from within templates, or within the .hbs portion of another component.

For example, our property rental application might have a component responsible for displaying all the rentals called all-rentals, and another component for displaying an individual rental called rental-tile. The rental-tile component could define a behavior that allows users to hide and show the image property of the rental.

Let's see these core concepts in action by beginning our first Ember application - Super Rentals - a site for property owners and renters to come together.

Application Setup and Structure
Ember implements the idea of "convention over configuration" in its design, opting to minimize the amount of configuration necessary to get an application up and running. Instead, it relies on consistent naming convention to match corresponding portions of the application.

To do this, a number of peripheral tasks to application development have been streamlined, such as testing, compiling, and serving files. This allows Ember developers to focus on building apps rather than building the support structures that make them run.

Ember includes a command line interface called Ember CLI with helpful tools that are immediately available at our fingertips!

Ember Help
In the terminal, a quick ember --help will display the commands available. For more information on a specific command, type ember help command-name. This shows us the details of how and when the command is used.

Creating a New Ember App
To start our new project called super-rentals, we'll navigate to the directory we'd like our app located in (most likely the Desktop) and use the new command:

$ ember new super-rentals
The Ember CLI Directory Structure
The new command generates a project structure with the following files and directories:

|--app
|--bower-components
|--config
|--dist
|--node_modules
|--public
|--tests
|--tmp
|--vendor

bower.json
ember-cli-build.js
package.json
README.md
testem.json
Let's take a brief look at the anatomy of an Ember application:

app: This is where folders and files for models, components, routes, templates and styles are stored. The vast majority of our coding happens in this folder.

bower-components / bower.json: bower is a dependency management tool. It is used to manage front-end plugins and component dependencies (HTML, CSS, JavaScript, etc). All bower components are installed in the bower-components directory. If we open bower.json, we see the list of dependencies that are installed by Ember automatically. These include Ember, jQuery, Ember Data and QUnit (for testing). If we add additional front-end dependencies, like bootstrap, they will also be listed here and their files added to the bower-components directory.

config: Contains the environment.js file which lists environmental settings and configurations for our app. We'll look at this more closely later.

dist: When an app is built for deployment, the output files will reside here.

node_modules / package.json: This directory and file are from npm. npm is the package manager for Node.js. Ember is built with Node and uses a variety of Node.js modules for operation. The package.json file comes pre-loaded with a list of current packages Ember requires. Any Ember-CLI add-ons you install will also show up here. Packages listed in package.json are installed in the node_modules directory.

public: This directory contains assets such as images and fonts.

vendor: This directory is where any front-end dependencies NOT managed by bower reside.

tests / testem.json: Contains automated tests for our app. Ember CLI's test runner testem is also configured in testem.json.

tmp: Temporary files live here.

ember-cli-build.js: Behind the scenes, Ember CLI uses a tool called Broccoli to compile our code. This file contains settings for how Broccoli should build our app.

ES6 Modules
If you take a look at an Ember application file (We'll use app/router.js as an example), you'll notice some syntax that may be unfamiliar to you.

app/router.js
import Ember from 'ember';
import config from './config/environment';

const Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
});

export default Router;
Ember CLI uses ECMAScript 6 (or ES6 for short) modules to organize application code. For example, the line import Ember from 'ember'; gives us access to the actual Ember.js library as the variable Ember. And the import config from './config/environment'; line provides access to our app's configuration data as the variable config. The line const Router = Ember.Router.... defines a constant called Router. (A constant is essentially a variable whose value cannot be re-assigned). At the end of the file, export default Router; makes this Router constant available to other parts of the application, similar to the fashion we've exported modules in previous weeks.

Starting the Ember Development Server
Once we have a new project in place, we can confirm everything is working by launching the Ember development server:

ember server
or, for short:

ember s
If we navigate to localhost:4200, we'll see a welcome message.

Overview
Ember Application Setup:

Ember builds all the support structures for you.
It automatically generates app/router.js
To create a new Ember app and its project folder named app-name enter this command:

$ ember new app-name
To start the server:

$ ember server
or shorthand:

$ ember s
App appears at localhost:4200 and it displays a welcome message.

Routes and Templates
Our Super Rentals site will begin with just a few static pages: A homepage, an about page and a contact page. Before we begin, let's consider what our application will look like from the user's perspective:

super rentals homepage screenshot

Users first arrive at a home page displaying all available rentals, as seen above. From here, they may navigate to the about and contact pages using links below the rental list.

Before we build these first three pages we'll need to remove the contents of the app/templates/application.hbs file (if it exists), leaving only the {{outlet}} line of code. We'll discuss the role of application.hbs more after our site has a few pages.

Important Note: You can ignore this step if you are using version 2.6 or later of ember-cli. These versions no longer include an application.hbs file automatically when you create a new project. We'll build one manually in an upcoming lesson.

An About Route
Let's start by crafting our "about" page. Remember, Ember follows the convention over configuration paradigm. So, when the URL path /about is loaded, the router will map the URL to the route handler of the same name, about.js. The route handler will then load the corresponding about.hbs template.

If we run ember help generate, we see a variety of tools come with Ember for automatically generating various files and resources. We'll use the route generator to build our about route:

$ ember generate route about
or for short,

$ ember g route about
We can see what actions are taken by the generator:

version: 2.4.2
installing route
  create app/routes/about.js
  create app/templates/about.hbs
updating router
  add route about
installing route-test
  create tests/unit/routes/about-test.js
Three new files are created:

A new route handler, located at app/routes/about.js
A file to contain the template the route handler will render, located at app/templates/about.hbs
A test file.
The existing router is also amended to include this new route.
When we open the router, we can see that the new about route the generator has automatically created for us. This route will load the about route handler.

app/router.js
import Ember from 'ember';
import config from './config/environment';

const Router = Ember.Router.extend({
  location: config.locationType
});

Router.map(function() {
  this.route('about');
});

export default Router;
By default, the about route handler loads the about.hbs template. We don't need to add anything to the app/routes/about.js file we just created for the about.hbs template to render automatically. That's what we mean when we say "convention over configuration". Because the proper naming conventions are in place (the route and template both share the name about, we don't need to manually configure the route handler to load the corresponding template; it does so automatically).

With routing in place, we can begin coding our template. When we open about.hbs we can see it currently contains one line: {{outlet}}. This is where something called a nested route could render if we had one. (Don't worry about this right now, we'll explore {{outlet}} tags in more detail later on!)

For now, we can simply remove this {{outlet}} tag, and instead add some HTML describing our site:

app/templates/about.hbs
<h2>About Super Rentals</h2>

<p>The Super Rentals website was created to explore the wonderful world of Ember.js. This project allows us to imagine traveling the world while simultaneously traversing the pathways of the Ember framework!</p>
If we launch the application by running $ ember serve, and visit localhost:4200/about in our browser we can see our new page in the browser. Awesome!

Overview
This is what the structure of our application currently looks like, and the steps that occur when we travel to the about route:



ember-structure-first-route



A Contact Route
Next, let's create another static page with contact information. Once again, we'll start by generating a route, a route handler, and a template with the following command:

$ ember g route contact
Again, we see that our generator has created:

a contact entry in our router
a corresponding route handler in app/routes/contact.js
a contact template.
Same as before, the contact route does not require anything additional to load automatically. Remember, convention over configuration.

In our contact.hbs template we'll add details for getting in touch with the fictitious Super Rentals company:

app/templates/contact.hbs
<p>Super Rentals Representatives would love to help you choose a destination or answer any burning questions you may have.</p>

<p>Contact us today!</p>

<p>
  Super Rentals Headquarters<br>
  1212 Test Address Avenue<br>
  TestyMcTestington, OR 97233
</p>

<p>(503) 555-1212</p>

<p>[email protected]</p>
We can also remove the {{outlet}} tag automatically included in our contact.hbs file again. We'll explore how to use these tags later on in the course. For now, we don't need them.

Now our second static page is now complete. If we navigate to localhost:4200/contact in the browser we can see our contact page.

Overview
If we continue mapping out the structure of our application as it grows, we can see that this second route followed the same pattern as the first:

tworoutesember

Navigating with Links and the {{link-to}} Helper
Of course, we don't want to require our users to manually enter URLs to navigate within our site. That's not user-friendly. Let's add navigational links at the bottom of each page.

First, we'll make a "contact" link on the about page and an "about" link on the contact page.

Ember has built-in helpers that provide basic functionality, such as linking between routes. These helpers are also sandwiched between Handlebars {{}} brackets. Here is how to use the {{link-to}} helper in a template:

app/templates/about.hbs
<h2>About Super Rentals</h2>

<p>The Super Rentals website was created to explore the wonderful world of Ember.js. This project allows us to imagine traveling the world while simultaneously traversing the pathways of the Ember framework!</p>

{{#link-to 'contact'}}Click here to contact us.{{/link-to}}
Notice the helper takes one simple argument: The name of the route this link should take the user to; in our case, the contact route. We can refresh the page and see our new link:

super rentals about page screenshot

Also, never include spaces between your opening or closing Handlebars brackets ({{ }}) and the content within them. We want our helpers to look like this:

{{#link-to 'contact'}}Click here to contact us.{{/link-to}}
NOT like this:

{{ #link-to 'contact' }}Click here to contact us.{{ /link-to }}
Including additional spaces in any Handlebars helper can lead to unexpected errors when your code compiles.

Next, let's add a link to our 'contact' page that will take users to our 'about' page:

app/templates/contact.hbs
<p>Super Rentals Representatives would love to help you choose a destination or answer any burning questions you may have.</p>

<p>Contact us today!</p>

<p>
  Super Rentals Headquarters<br>
  1212 Test Address Avenue<br>
  TestyMcTestington, OR 97233
</p>

<p>(503) 555-1212</p>

<p>superrentalsrep@superrentals.com</p>

{{#link-to 'about'}}About{{/link-to}}
An Index Route
Let's also include a homepage to welcome users. Just like our previous pages, we will first generate a new route. Let's call this one "index":

$ ember g route index
version: 2.4.2
installing route
  create app/routes/index.js
  create app/templates/index.hbs
installing route-test
  create tests/unit/routes/index-test.js
Unlike the other two routes we've created, the index route is special: It does NOT require an entry in the router. You'll also notice that generating this route did not alter app/router.js at all.

We'll learn more about why this entry isn't required later on. For now, just know the index route is not listed in the router. We can find it at the default path localhost:4200.

We'll update our new index.hbs template with links to our other two routes:

app/templates/index.hbs
<h1> Welcome to Super Rentals </h1>

We hope you find exactly what you're looking for in a place to stay.

{{#link-to 'about'}}About{{/link-to}}
{{#link-to 'contact'}}Click here to contact us.{{/link-to}}
Now, we have three unique routes: the default index route, the about route, and the contact route. Great work!

Models
Our application now contains three static pages, and navigational links for users to travel between them. Next, let's add functionality to list available rental properties!

We know that our list of rentals will not be static. Eventually, users must be able to add, update and delete them. For this reason, we require a rentals model. This model will save information about each rental. Our model will begin as a simple hard-coded array of JavaScript objects.

Later on we'll implement something called Ember Data and allow users to create and modify their own rentals. We'll also save this information in a database.

Here's what our homepage will look like when we're done:

super rentals homepage with rentals list

Remember, each time we create a new route, a route handler and template are both generated.

The route handler is the .js file that corresponds to the .hbs template file of the same name. The route handler is responsible for loading model data.
This data is then available in the corresponding template. It may also be passed to any child components rendered within this template.
The route handler is the only part of an Ember application that can access model data. We can display model information in a template, but that template's route handler must retrieve it for the template.
Model Data
Let's open app/routes/index.js and add some hard-coded data to act as our model:

app/routes/index.js
import Ember from 'ember';

var rentals = [{
  id: 1,
  owner: "Veruca Salt",
  city: "San Francisco",
  type: "Estate",
  bedrooms: 15,
  image: "https://upload.wikimedia.org/wikipedia/commons/c/cb/Crane_estate_(5).jpg"
}, {
  id: 2,
  owner: "Mike TV",
  city: "Seattle",
  type: "Condo",
  bedrooms: 1,
  image: "https://upload.wikimedia.org/wikipedia/commons/0/0e/Alfonso_13_Highrise_Tegucigalpa.jpg"
}, {
  id: 3,
  owner: "Violet Beauregarde",
  city: "Portland",
  type: "Apartment",
  bedrooms: 3,
  image: "https://upload.wikimedia.org/wikipedia/commons/f/f7/Wheeldon_Apartment_Building_-_Portland_Oregon.jpg"
}];

export default Ember.Route.extend({
  model() {
    return rentals;
  },
});
Note: If you haven't used the ES6 shorthand method definition syntax before, model() is the same as writing model: function().

A method within an Ember class is called a hook. In the code above we've added the following model hook to our index route handler:

...
  model() {
    return rentals;
  },
...
The model hook returns our hard-coded array of rentals. This data is now available to the route's corresponding index.hbs template as the model property. That is, when we refer to the keyword model in the index.hbs template, we're referring to this array of rentals from the index.js route handler.

Model data in a route handler is available to the templates and components that correspond to that route. The index.hbs template may now display our model data (an array of rentals) because this data is within its context. That is, defined on its corresponding route handler.

Displaying Model Data
Now that our index.js route handler has access to our rental data within its model hook, we can display it in the route handler's corresponding index.hbs template.

Do note that we will eventually display this information in components; not directly on the template. We'll refactor this code together in upcoming lessons when we learn about components. But for now we'll confirm our model hook is functioning by displaying our data in the index.hbs template.

To do this, we'll use another helper called {{#each}}. This helper allows us to loop through each object in our model and display its information:

app/templates/index.hbs
<h1> Welcome to Super Rentals </h1>

We hope you find exactly what you're looking for in a place to stay.

<ul>
  {{#each model as |rental|}}
     <li>{{rental.owner}}'s {{rental.type}} in {{rental.city}}</li>
  {{/each}}
</ul>

{{#link-to 'about'}}About{{/link-to}}
{{#link-to 'contact'}}Click here to contact us.{{/link-to}}

Here we create an unordered list. We loop through each object in the model hook defined in the index route handler, and call it rental. For each rental, we create a list item and display its owner, type and city properties.
